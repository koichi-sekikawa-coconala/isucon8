.\" Automatically generated by Pod::Man 4.10 (Pod::Simple 3.35)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is >0, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{\
.    if \nF \{\
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{\
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\" ========================================================================
.\"
.IX Title "Time::Moment 3"
.TH Time::Moment 3 "2018-03-08" "perl v5.28.0" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Time::Moment \- Represents a date and time of day with an offset from UTC
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 10
\&    $tm = Time::Moment\->new(
\&        year       => 2012,
\&        month      => 12,
\&        day        => 24,
\&        hour       => 15,
\&        minute     => 30,
\&        second     => 45,
\&        nanosecond => 123456789,
\&        offset     => 0,
\&    );
\&    $tm = Time::Moment\->now;
\&    $tm = Time::Moment\->now_utc;
\&    $tm = Time::Moment\->from_epoch($seconds);
\&    $tm = Time::Moment\->from_object($object);
\&    $tm = Time::Moment\->from_string($string);
\&    $tm = Time::Moment\->from_rd($rd);
\&    $tm = Time::Moment\->from_jd($jd);
\&    $tm = Time::Moment\->from_mjd($mjd);
\&    
\&    $year         = $tm\->year;                      # [1, 9999]
\&    $quarter      = $tm\->quarter;                   # [1, 4]
\&    $month        = $tm\->month;                     # [1, 12]
\&    $week         = $tm\->week;                      # [1, 53]
\&    
\&    $day          = $tm\->day_of_year;               # [1, 366]
\&    $day          = $tm\->day_of_quarter;            # [1, 92]
\&    $day          = $tm\->day_of_month;              # [1, 31]
\&    $day          = $tm\->day_of_week;               # [1=Monday, 7=Sunday]
\&    
\&    $hour         = $tm\->hour;                      # [0, 23]
\&    $minute       = $tm\->minute;                    # [0, 59]
\&    $minute       = $tm\->minute_of_day;             # [0, 1439]
\&    $second       = $tm\->second;                    # [0, 59]
\&    $second       = $tm\->second_of_day;             # [0, 86_399]
\&    $millisecond  = $tm\->millisecond;               # [0, 999]
\&    $millisecond  = $tm\->millisecond_of_day;        # [0, 86_399_999]
\&    $microsecond  = $tm\->microsecond;               # [0, 999_999]
\&    $microsecond  = $tm\->microsecond_of_day;        # [0, 86_399_999_999]
\&    $nanosecond   = $tm\->nanosecond;                # [0, 999_999_999]
\&    $nanosecond   = $tm\->nanosecond_of_day;         # [0, 86_399_999_999_999]
\&    
\&    $epoch        = $tm\->epoch;
\&    $offset       = $tm\->offset;                    # [\-1080, 1080] (±18:00)
\&    
\&    $jd           = $tm\->jd;                        # Julian Date
\&    $mjd          = $tm\->mjd;                       # Modified Julian Date
\&    $rd           = $tm\->rd;                        # Rata Die
\&    
\&    $tm2          = $tm1\->with($adjuster);
\&    $tm2          = $tm1\->with_year($year);
\&    $tm2          = $tm1\->with_quarter($quarter);
\&    $tm2          = $tm1\->with_month($month);
\&    $tm2          = $tm1\->with_week($week);
\&    $tm2          = $tm1\->with_day_of_year($day);
\&    $tm2          = $tm1\->with_day_of_quarter($day);
\&    $tm2          = $tm1\->with_day_of_month($day);
\&    $tm2          = $tm1\->with_day_of_week($day);
\&    $tm2          = $tm1\->with_hour($hour);
\&    $tm2          = $tm1\->with_minute($minute);
\&    $tm2          = $tm1\->with_minute_of_day($minute);
\&    $tm2          = $tm1\->with_second($second);
\&    $tm2          = $tm1\->with_second_of_day($second);
\&    $tm2          = $tm1\->with_millisecond($millisecond);
\&    $tm2          = $tm1\->with_millisecond_of_day($millisecond);
\&    $tm2          = $tm1\->with_microsecond($microsecond);
\&    $tm2          = $tm1\->with_microsecond_of_day($microsecond);
\&    $tm2          = $tm1\->with_nanosecond($nanosecond);
\&    $tm2          = $tm1\->with_nanosecond_of_day($nanosecond);
\&    
\&    $tm2          = $tm1\->with_offset_same_instant($offset);
\&    $tm2          = $tm1\->with_offset_same_local($offset);
\&    
\&    $tm2          = $tm1\->with_precision($precision);
\&    
\&    $tm2          = $tm1\->plus_years($years);
\&    $tm2          = $tm1\->plus_months($months);
\&    $tm2          = $tm1\->plus_weeks($weeks);
\&    $tm2          = $tm1\->plus_days($days);
\&    $tm2          = $tm1\->plus_hours($hours);
\&    $tm2          = $tm1\->plus_minutes($minutes);
\&    $tm2          = $tm1\->plus_seconds($seconds);
\&    $tm2          = $tm1\->plus_milliseconds($milliseconds);
\&    $tm2          = $tm1\->plus_microseconds($microseconds);
\&    $tm2          = $tm1\->plus_nanoseconds($nanoseconds);
\&    
\&    $tm2          = $tm1\->minus_years($years);
\&    $tm2          = $tm1\->minus_months($months);
\&    $tm2          = $tm1\->minus_weeks($weeks);
\&    $tm2          = $tm1\->minus_days($days);
\&    $tm2          = $tm1\->minus_hours($hours);
\&    $tm2          = $tm1\->minus_minutes($minutes);
\&    $tm2          = $tm1\->minus_seconds($seconds);
\&    $tm2          = $tm1\->minus_milliseconds($milliseconds);
\&    $tm2          = $tm1\->minus_microseconds($microseconds);
\&    $tm2          = $tm1\->minus_nanoseconds($nanoseconds);
\&    
\&    $years        = $tm1\->delta_years($tm2);
\&    $months       = $tm1\->delta_months($tm2);
\&    $weeks        = $tm1\->delta_weeks($tm2);
\&    $days         = $tm1\->delta_days($tm2);
\&    $hours        = $tm1\->delta_hours($tm2);
\&    $minutes      = $tm1\->delta_minutes($tm2);
\&    $seconds      = $tm1\->delta_seconds($tm2);
\&    $milliseconds = $tm1\->delta_milliseconds($tm2);
\&    $microseconds = $tm1\->delta_microseconds($tm2);
\&    $nanoseconds  = $tm1\->delta_nanoseconds($tm2);
\&    
\&    $tm2          = $tm1\->at_utc;
\&    
\&    $tm2          = $tm1\->at_midnight;              # T00:00:00.0
\&    $tm2          = $tm1\->at_noon;                  # T12:00:00.0
\&    
\&    $tm2          = $tm1\->at_last_day_of_year;
\&    $tm2          = $tm1\->at_last_day_of_quarter;
\&    $tm2          = $tm1\->at_last_day_of_month;
\&    
\&    $boolean      = $tm1\->is_before($tm2);
\&    $boolean      = $tm1\->is_after($tm2);
\&    $boolean      = $tm1\->is_equal($tm2);
\&    
\&    $integer      = $tm1\->compare($tm2);
\&    
\&    $boolean      = $tm\->is_leap_year;
\&    
\&    $string       = $tm\->to_string;
\&    $string       = $tm\->strftime($format);
\&    
\&    $integer      = $tm\->length_of_year;            # [365, 366]
\&    $integer      = $tm\->length_of_quarter;         # [90, 92]
\&    $integer      = $tm\->length_of_month;           # [28, 31]
\&    $integer      = $tm\->length_of_week_year;       # [52, 53]
\&    
\&    @values       = $tm\->utc_rd_values;
\&    $seconds      = $tm\->utc_rd_as_seconds;
\&    @values       = $tm\->local_rd_values;
\&    $seconds      = $tm\->local_rd_as_seconds;
\&    
\&    $integer      = $tm1 <=> $tm2;
\&    
\&    $boolean      = $tm1 == $tm2;
\&    $boolean      = $tm1 != $tm2;
\&    $boolean      = $tm1 <  $tm2;
\&    $boolean      = $tm1 >  $tm2;
\&    $boolean      = $tm1 <= $tm2;
\&    $boolean      = $tm1 >= $tm2;
\&    
\&    $string       = "$tm";
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
\&\f(CW\*(C`Time::Moment\*(C'\fR is an immutable object representing a date and time of day 
with an offset from \s-1UTC\s0 in the \s-1ISO 8601\s0 calendar system.
.PP
Time is measured in nanoseconds since \f(CW\*(C`0001\-01\-01T00Z\*(C'\fR. In \f(CW\*(C`Time:Moment\*(C'\fR 
leap seconds are ignored. It is assumed that there are exactly 
\&\f(CW\*(C`86,400,000,000,000\*(C'\fR nanoseconds per day. \f(CW\*(C`Time::Moment\*(C'\fR can represent 
all epoch integers from \f(CW\*(C`\-62,135,596,800\*(C'\fR to \f(CW\*(C`253,402,300,799\*(C'\fR; this 
range suffices to measure times to nanosecond precision for any instant 
that is within \f(CW\*(C`0001\-01\-01T00:00:00Z\*(C'\fR to \f(CW\*(C`9999\-12\-31T23:59:59Z\*(C'\fR.
.SH "CONSTRUCTORS"
.IX Header "CONSTRUCTORS"
.SS "new"
.IX Subsection "new"
.Vb 10
\&    $tm = Time::Moment\->new(
\&        year       => 2012,
\&        month      => 12,
\&        day        => 24,
\&        hour       => 15,
\&        minute     => 30,
\&        second     => 45,
\&        nanosecond => 123456789,
\&        offset     => 0,
\&    );
.Ve
.PP
Constructs an instance of \f(CW\*(C`Time::Moment\*(C'\fR from the given components.
.PP
\&\fBParameters:\fR
.IP "year" 4
.IX Item "year"
The year [1, 9999].
.IP "month" 4
.IX Item "month"
The month of the year [1, 12].
.IP "day" 4
.IX Item "day"
The day of the month [1, 31]. The day must be valid for the year and month, 
otherwise an exception is raised.
.IP "hour" 4
.IX Item "hour"
The hour of the day [0, 23].
.IP "minute" 4
.IX Item "minute"
The minute of the hour [0, 59].
.IP "second" 4
.IX Item "second"
The second of the minute [0, 59].
.IP "nanosecond" 4
.IX Item "nanosecond"
The nanosecond of the second [0, 999_999_999].
.IP "offset" 4
.IX Item "offset"
The offset from \s-1UTC\s0 in minutes [\-1080, 1080] (±18:00).
.SS "now"
.IX Subsection "now"
.Vb 1
\&    $tm = Time::Moment\->now;
.Ve
.PP
Constructs an instance of \f(CW\*(C`Time::Moment\*(C'\fR that is set to the current date 
and time from the system clock in the system time zone, with the offset 
set to the system's time zone offset from \s-1UTC.\s0
.SS "now_utc"
.IX Subsection "now_utc"
.Vb 1
\&    $tm = Time::Moment\->now_utc;
.Ve
.PP
Constructs an instance of \f(CW\*(C`Time::Moment\*(C'\fR that is set to the current date 
and time from the system clock in the \s-1UTC\s0 time zone.
.SS "from_epoch"
.IX Subsection "from_epoch"
.Vb 3
\&    $tm = Time::Moment\->from_epoch($seconds);
\&    $tm = Time::Moment\->from_epoch($seconds, $nanosecond);
\&    $tm = Time::Moment\->from_epoch($seconds [, nanosecond => 0] [, precision => 6]);
.Ve
.PP
Constructs an instance of \f(CW\*(C`Time::Moment\*(C'\fR from the given \fIseconds\fR from the 
epoch of 1970\-01\-01T00Z. Fractional seconds is supported if the constructor 
is invoked with \fIseconds\fR only, the default precision is 6 (microseconds).
.PP
\&\fBParameters:\fR
.IP "nanosecond" 4
.IX Item "nanosecond"
.Vb 1
\&    $tm = Time::Moment\->from_epoch($seconds, nanosecond => 0);
.Ve
.Sp
The optional parameter \fInanosecond\fR [0, 999_999_999] specifies the 
nanosecond of the second.
.IP "precision" 4
.IX Item "precision"
.Vb 1
\&    $tm = Time::Moment\->from_epoch($seconds, precision => 6);
.Ve
.Sp
The optional parameter \fIprecision\fR [0, 9] specifies the precision of the
fractional seconds. The default precision is 6 (microseconds).
.SS "from_object"
.IX Subsection "from_object"
.Vb 1
\&    $tm = Time::Moment\->from_object($object);
.Ve
.PP
Constructs an instance of \f(CW\*(C`Time::Moment\*(C'\fR from the given \fIobject\fR. If the 
given object is an instance of \f(CW\*(C`Time::Moment\*(C'\fR it's returned otherwise an 
attempt is made to coerce the given object to an instance of \f(CW\*(C`Time::Moment\*(C'\fR.
.PP
\&\f(CW\*(C`Time::Moment\*(C'\fR implements coercion handlers for the following object types:
.IP "DateTime" 4
.IX Item "DateTime"
.Vb 1
\&    $tm = Time::Moment\->from_object( DateTime\->now );
.Ve
.Sp
The given \f(CW\*(C`DateTime\*(C'\fR object must be within the supported range and must have 
a time zone or an offset from \s-1UTC,\s0 coercing from the 'floating' time zone is 
not supported.
.IP "Time::Piece" 4
.IX Item "Time::Piece"
.Vb 1
\&    $tm = Time::Moment\->from_object( scalar Time::Piece::localtime() );
.Ve
.Sp
The given \f(CW\*(C`Time::Piece\*(C'\fR object must be within the supported date range.
.PP
The coercion scheme is extensible and implemented as documented in 
Params::Coerce:
.PP
.Vb 2
\&    $tm = Params::Coerce::coerce(\*(AqTime::Moment\*(Aq, scalar Time::Piece::localtime());
\&    $tm = Params::Coerce::coerce(\*(AqTime::Moment\*(Aq, DateTime\->now);
.Ve
.PP
\&\f(CW\*(C`Time::Moment\*(C'\fR also implements a coercion handler from \f(CW\*(C`Time::Moment\*(C'\fR to 
\&\f(CW\*(C`DateTime\*(C'\fR and \f(CW\*(C`Time::Piece\*(C'\fR:
.PP
.Vb 2
\&    $dt = Params::Coerce::coerce(\*(AqDateTime\*(Aq, Time::Moment\->now);
\&    $tp = Params::Coerce::coerce(\*(AqTime::Piece\*(Aq, Time::Moment\->now);
.Ve
.SS "from_string"
.IX Subsection "from_string"
.Vb 2
\&    $tm = Time::Moment\->from_string($string);
\&    $tm = Time::Moment\->from_string($string [, lenient => false]);
.Ve
.PP
Constructs an instance of \f(CW\*(C`Time::Moment\*(C'\fR from the given \fIstring\fR. The 
string must consist of a complete date representation and time of day 
followed by a zone designator. The time of day may be reduced to hour 
of the day, the second of the minute may have a decimal fraction. The decimal 
sign can be either the comma [,] or the full stop [.]. A decimal fraction 
must have at least one digit and may have a total of nine digits, if the 
fractional precision is greater than nine digits, the value will be 
truncated.
.PP
The following are examples of complete date and time of day representations:
.PP
.Vb 4
\&    Basic format:                 Example:
\&    YYYYMMDDThhmmssZ              20121224T121530Z
\&    YYYYMMDDThhmmss±hhmm          20121224T121530+0100
\&    YYYYMMDDThhmmss±hh            20121224T121530+01
\&    
\&    YYYYMMDDThhmmss.ssZ           20121224T121530.500Z
\&    YYYYMMDDThhmmss.ss±hhmm       20121224T121530.500+0100
\&    YYYYMMDDThhmmss.ss±hh         20121224T121530.500+01
\&    
\&    YYYYMMDDThhZ                  20121224T12Z              (reduced accuracy)
\&    YYYYMMDDThhmmZ                20121224T1215Z            (reduced accuracy)
\&    YYYYMMDDThhmm±hhmm            20121224T1215+0100        (reduced accuracy)
\&    YYYYMMDDThhmm±hh              20121224T1215+01          (reduced accuracy)
\&    
\&    Extended format:              Example:
\&    YYYY\-MM\-DDThh:mm:ssZ          2012\-12\-24T12:15:30Z
\&    YYYY\-MM\-DDThh:mm:ss±hh:mm     2012\-12\-24T12:15:30+01:00
\&    YYYY\-MM\-DDThh:mm:ss±hh        2012\-12\-24T12:15:30+01
\&    
\&    YYYY\-MM\-DDThh:mm:ss.ssZ       2012\-12\-24T12:15:30.500Z
\&    YYYY\-MM\-DDThh:mm:ss.ss±hh:mm  2012\-12\-24T12:15:30.500+01:00
\&    YYYY\-MM\-DDThh:mm:ss.ss±hh     2012\-12\-24T12:15:30.500+01
\&    
\&    YYYY\-MM\-DDThhZ                2012\-12\-24T12Z            (reduced accuracy)
\&    YYYY\-MM\-DDThh:mmZ             2012\-12\-24T12:15Z         (reduced accuracy)
\&    YYYY\-MM\-DDThh:mm±hh:mm        2012\-12\-24T12:15+01:00    (reduced accuracy)
\&    YYYY\-MM\-DDThh:mm±hh           2012\-12\-24T12:15+01       (reduced accuracy)
.Ve
.PP
Where representations using calendar dates are shown, ordinal dates or week 
dates may be substituted. This \s-1ISO 8601\s0 profile correspond to a subset of 
\&\s-1ISO 8601:2004 4.3\s0 Date and time of day.
.PP
If the optional boolean parameter \fIlenient\fR is true, the following examples
are also accepted:
.PP
.Vb 5
\&    YYYY\-MM\-DD hh:mm:ssZ          2012\-12\-24 12:15:30Z
\&    YYYY\-MM\-DD hh:mm:ssz          2012\-12\-24 12:15:30z
\&    YYYY\-MM\-DD hh:mm:ss±hhmm      2012\-12\-24 12:15:30+0100
\&    YYYY\-MM\-DD hh:mm:ss±hh:mm     2012\-12\-24 12:15:30+01:00
\&    YYYY\-MM\-DD hh:mm:ss±hh        2012\-12\-24 12:15:30+01
\&    
\&    YYYY\-MM\-DD hh:mm:ss.ssZ       2012\-12\-24 12:15:30.500Z
\&    YYYY\-MM\-DD hh:mm:ss.ssz       2012\-12\-24 12:15:30.500z
\&    YYYY\-MM\-DD hh:mm:ss.ss±hhmm   2012\-12\-24 12:15:30.500+0100
\&    YYYY\-MM\-DD hh:mm:ss.ss±hh:mm  2012\-12\-24 12:15:30.500+01:00
\&    YYYY\-MM\-DD hh:mm:ss.ss±hh     2012\-12\-24 12:15:30.500+01
\&    
\&    YYYY\-MM\-DD hh:mmZ             2012\-12\-24 12:15Z
\&    YYYY\-MM\-DD hh:mmz             2012\-12\-24 12:15z
\&    YYYY\-MM\-DD hh:mm±hhmm         2012\-12\-24 12:15+0100
\&    YYYY\-MM\-DD hh:mm±hh:mm        2012\-12\-24 12:15+01:00
\&    YYYY\-MM\-DD hh:mm±hh           2012\-12\-24 12:15+01
\&    
\&    YYYY\-MM\-DD hh:mm:ss ±hh:mm    2012\-12\-24 12:15:30 +01:00
\&    YYYY\-MM\-DD hh:mm:ss ±hhmm     2012\-12\-24 12:15:30 +0100
\&    YYYY\-MM\-DD hh:mm:ss ±hh       2012\-12\-24 12:15:30 +01
\&    YYYY\-MM\-DD hh:mm:ss GMT       2012\-12\-24 12:15:30 GMT
\&    YYYY\-MM\-DD hh:mm:ss GMT±hh    2012\-12\-24 12:15:30 GMT+01
\&    YYYY\-MM\-DD hh:mm:ss UTC       2012\-12\-24 12:15:30 UTC
\&    YYYY\-MM\-DD hh:mm:ss UTC±hh    2012\-12\-24 12:15:30 UTC+01
\&    
\&    YYYY\-MM\-DD hh:mm:ss.ss ±hhmm  2012\-12\-24 12:15:30.500 +0100
\&    YYYY\-MM\-DD hh:mm:ss.ss ±hh:mm 2012\-12\-24 12:15:30.500 +01:00
\&    YYYY\-MM\-DD hh:mm:ss.ss ±hh    2012\-12\-24 12:15:30.500 +01
\&    
\&    YYYY\-MM\-DD hh:mm ±hh:mm       2012\-12\-24 12:15 +01:00
\&    YYYY\-MM\-DD hh:mm ±hhmm        2012\-12\-24 12:15 +0100
\&    YYYY\-MM\-DD hh:mm ±hh          2012\-12\-24 12:15 +01
.Ve
.PP
The string representation may consist of a mixture of the basic format and 
the extended format. The time designator [T] may be in lower case [t] or 
replaced with a single space. A single space is also accepted between the 
time of day and the zone designator. The \s-1UTC\s0 designator [Z] may also be in 
lower case [z]. The literal string \s-1GMT\s0 or \s-1UTC\s0 may be used as a \s-1UTC\s0 designator 
and may have an offset. Usage of these string representations is strongly 
discouraged as they do not conform to the \s-1ISO 8601\s0 standard.
.SS "from_rd"
.IX Subsection "from_rd"
.Vb 2
\&    $tm = Time::Moment\->from_rd($rd);
\&    $tm = Time::Moment\->from_rd($rd [, offset => 0] [, precision => 3] [, epoch => 0]);
.Ve
.PP
Constructs an instance of \f(CW\*(C`Time::Moment\*(C'\fR from the given Rata Die. 
The Rata Die is a count of days elapsed since 0000\-12\-31T00. The 
fractional part corresponds to the fraction of the day after midnight. 
The minimum acceptable Rata Die is \f(CW1\fR which corresponds to 
0001\-01\-01T00.
.PP
\&\fBParameters:\fR
.IP "offset" 4
.IX Item "offset"
.Vb 1
\&    $tm = Time::Moment\->from_rd($rd, offset => 0);
.Ve
.Sp
The optional parameter \fIoffset\fR [\-1080, 1080] (±18:00) specifies the 
offset from \s-1UTC\s0 in minutes. The default offset is 0.
.IP "precision" 4
.IX Item "precision"
.Vb 1
\&    $tm = Time::Moment\->from_rd($rd, precision => 3);
.Ve
.Sp
The optional parameter \fIprecision\fR [0, 9] specifies the precision of the
fractional seconds. The default precision is 3 (milliseconds).
.IP "epoch" 4
.IX Item "epoch"
.Vb 1
\&    $tm = Time::Moment\->from_rd($rd, epoch => 0);
.Ve
.Sp
The optional parameter \fIepoch\fR specifies the epoch date relative to 
0000\-12\-31T00. The epoch date for the Rata Die is \f(CW0\fR.
.SS "from_jd"
.IX Subsection "from_jd"
.Vb 2
\&    $tm = Time::Moment\->from_jd($jd);
\&    $tm = Time::Moment\->from_jd($jd [, precision => 3] [, epoch => \-1721424.5]);
.Ve
.PP
Constructs an instance of \f(CW\*(C`Time::Moment\*(C'\fR from the given Julian Date. 
The Julian Date is a count of days elapsed since \-4713\-11\-24T12Z. The 
fractional part corresponds to the fraction of the day after noon. The 
minimum acceptable Julian Date is \f(CW1721425.5\fR which corresponds to 
0001\-01\-01T00Z.
.PP
\&\fBParameters:\fR
.IP "precision" 4
.IX Item "precision"
.Vb 1
\&    $tm = Time::Moment\->from_jd($jd, precision => 3);
.Ve
.Sp
The optional parameter \fIprecision\fR [0, 9] specifies the precision of the
fractional seconds. The default precision is 3 (milliseconds).
.IP "epoch" 4
.IX Item "epoch"
.Vb 1
\&    $tm = Time::Moment\->from_jd($jd, epoch => \-1721424.5);
.Ve
.Sp
The optional parameter \fIepoch\fR specifies the epoch date relative to 
0000\-12\-31T00Z. The epoch date for the Julian Date is \f(CW\*(C`\-1721424.5\*(C'\fR.
.SS "from_mjd"
.IX Subsection "from_mjd"
.Vb 2
\&    $tm = Time::Moment\->from_mjd($mjd);
\&    $tm = Time::Moment\->from_mjd($mjd [, precision => 3] [, epoch => 678576]);
.Ve
.PP
Constructs an instance of \f(CW\*(C`Time::Moment\*(C'\fR from the given Modified Julian 
Date. The Modified Julian Date is a count of days elapsed since 
1858\-11\-17T00Z. The fractional part corresponds to the fraction of the day 
after midnight. The minimum acceptable Modified Julian Date is \f(CW\*(C`\-678575\*(C'\fR 
which corresponds to 0001\-01\-01T00Z.
.PP
\&\fBParameters:\fR
.IP "precision" 4
.IX Item "precision"
.Vb 1
\&    $tm = Time::Moment\->from_mjd($mjd, precision => 3);
.Ve
.Sp
The optional parameter \fIprecision\fR [0, 9] specifies the precision of the
fractional seconds. The default precision is 3 (milliseconds).
.IP "epoch" 4
.IX Item "epoch"
.Vb 1
\&    $tm = Time::Moment\->from_mjd($mjd, epoch => 678576);
.Ve
.Sp
The optional parameter \fIepoch\fR specifies the epoch date relative to 
0000\-12\-31T00Z. The epoch date for the Modified Julian Date is \f(CW678576\fR.
.SH "INSTANCE METHODS"
.IX Header "INSTANCE METHODS"
.SS "year"
.IX Subsection "year"
.Vb 1
\&    $year = $tm\->year;
.Ve
.PP
Returns the year [1, 9999].
.SS "quarter"
.IX Subsection "quarter"
.Vb 1
\&    $quarter = $tm\->quarter;
.Ve
.PP
Returns the quarter of the year [1, 4].
.SS "month"
.IX Subsection "month"
.Vb 1
\&    $month = $tm\->month;
.Ve
.PP
Returns the month of the year [1, 12].
.SS "week"
.IX Subsection "week"
.Vb 1
\&    $week = $tm\->week;
.Ve
.PP
Returns the week of the year [1, 53].
.SS "day_of_year"
.IX Subsection "day_of_year"
.Vb 1
\&    $day = $tm\->day_of_year;
.Ve
.PP
Returns the day of the year [1, 366].
.SS "day_of_quarter"
.IX Subsection "day_of_quarter"
.Vb 1
\&    $day = $tm\->day_of_quarter;
.Ve
.PP
Returns the day of the quarter [1, 92].
.SS "day_of_month"
.IX Subsection "day_of_month"
.Vb 1
\&    $day = $tm\->day_of_month;
.Ve
.PP
Returns the day of the month [1, 31].
.SS "day_of_week"
.IX Subsection "day_of_week"
.Vb 1
\&    $day = $tm\->day_of_week;
.Ve
.PP
Returns the day of the week [1=Monday, 7=Sunday].
.SS "hour"
.IX Subsection "hour"
.Vb 1
\&    $hour = $tm\->hour;
.Ve
.PP
Returns the hour of the day [0, 23].
.SS "minute"
.IX Subsection "minute"
.Vb 1
\&    $minute = $tm\->minute;
.Ve
.PP
Returns the minute of the hour [0, 59].
.SS "minute_of_day"
.IX Subsection "minute_of_day"
.Vb 1
\&    $minute = $tm\->minute_of_day;
.Ve
.PP
Returns the minute of the day [0, 1439].
.SS "second"
.IX Subsection "second"
.Vb 1
\&    $second = $tm\->second;
.Ve
.PP
Returns the second of the minute [0, 59].
.SS "second_of_day"
.IX Subsection "second_of_day"
.Vb 1
\&    $second = $tm\->second_of_day;
.Ve
.PP
Returns the second of the day [0, 86_399].
.SS "millisecond"
.IX Subsection "millisecond"
.Vb 1
\&    $millisecond = $tm\->millisecond;
.Ve
.PP
Returns the millisecond of the second [0, 999].
.SS "millisecond_of_day"
.IX Subsection "millisecond_of_day"
.Vb 1
\&    $millisecond = $tm\->millisecond_of_day;
.Ve
.PP
Returns the millisecond of the day [0, 86_399_999].
.SS "microsecond"
.IX Subsection "microsecond"
.Vb 1
\&    $microsecond = $tm\->microsecond;
.Ve
.PP
Returns the microsecond of the second [0, 999_999].
.SS "microsecond_of_day"
.IX Subsection "microsecond_of_day"
.Vb 1
\&    $microsecond = $tm\->microsecond_of_day;
.Ve
.PP
Returns the microsecond of the day [0, 86_399_999_999].
.SS "nanosecond"
.IX Subsection "nanosecond"
.Vb 1
\&    $nanosecond = $tm\->nanosecond;
.Ve
.PP
Returns the nanosecond of the second [0, 999_999_999].
.SS "nanosecond_of_day"
.IX Subsection "nanosecond_of_day"
.Vb 1
\&    $nanosecond = $tm\->nanosecond_of_day;
.Ve
.PP
Returns the nanosecond of the day [0, 86_399_999_999_999].
.SS "epoch"
.IX Subsection "epoch"
.Vb 1
\&    $epoch = $tm\->epoch;
.Ve
.PP
Returns the number of integral seconds from the epoch of 1970\-01\-01T00Z.
.SS "offset"
.IX Subsection "offset"
.Vb 1
\&    $offset = $tm\->offset;
.Ve
.PP
Returns the offset from \s-1UTC\s0 in minutes [\-1080, 1080] (±18:00).
.SS "precision"
.IX Subsection "precision"
.Vb 1
\&    $precision = $tm\->precision;
.Ve
.PP
Returns the precision of the time of the day [\-3, 9]. Please see 
with_precision for an explanation of the 
returned precision value.
.SS "jd"
.IX Subsection "jd"
.Vb 2
\&    $jd = $tm\->jd;
\&    $jd = $tm\->jd([precision => 3]);
.Ve
.PP
Returns the Julian Date. The Julian Date is a count of days elapsed since 
\&\-4713\-11\-24T12Z. The fractional part corresponds to the fraction of the 
day after noon. The optional named parameter \fIprecision\fR [0, 9] specifies 
the precision of the fractional seconds. The default precision is 3 
(milliseconds).
.SS "mjd"
.IX Subsection "mjd"
.Vb 2
\&    $mjd = $tm\->mjd;
\&    $mjd = $tm\->mjd([precision => 3]);
.Ve
.PP
Returns the Modified Julian Date. The Modified Julian Date is a count of days 
elapsed since 1858\-11\-17T00Z. The fractional part corresponds to the fraction 
of the day after midnight. The optional named parameter \fIprecision\fR [0, 9] 
specifies the precision of the fractional seconds. The default precision is 3 
(milliseconds).
.SS "rd"
.IX Subsection "rd"
.Vb 2
\&    $rd = $tm\->rd;
\&    $rd = $tm\->rd([precision => 3]);
.Ve
.PP
Returns the Rata Die. The Rata Die is a count of days elapsed since 
0000\-12\-31T00. The fractional part corresponds to the fraction of the day 
after midnight. The optional named parameter \fIprecision\fR [0, 9] specifies 
the precision of the fractional seconds. The default precision is 3 
(milliseconds).
.SS "with"
.IX Subsection "with"
.Vb 1
\&    $tm2 = $tm1\->with($adjuster);
.Ve
.PP
Returns a copy of this instance adjusted by the given \fIadjuster\fR. The 
adjuster is a \s-1CODE\s0 reference invoked with an instance of Time::Moment and
is expected to return an instance of Time::Moment. Please see 
Time::Moment::Adjusters for available adjusters.
.SS "with_year"
.IX Subsection "with_year"
.Vb 1
\&    $tm2 = $tm1\->with_year($year);
.Ve
.PP
Returns a copy of this instance with the given \fIyear\fR [1, 9999] altered. The
day of the month of the date is unchanged unless the day does not exist in the 
month. In that case, the day is set to the last day of the month.
.SS "with_quarter"
.IX Subsection "with_quarter"
.Vb 1
\&    $tm2 = $tm1\->with_quarter($quarter);
.Ve
.PP
Returns a copy of this instance with the given \fIquarter\fR of the year [1, 4] 
altered. The day of the month of the date is unchanged unless the day does 
not exist in the month of the quarter. In that case, the day is set to the 
last day of the month.
.SS "with_month"
.IX Subsection "with_month"
.Vb 1
\&    $tm2 = $tm1\->with_month($month);
.Ve
.PP
Returns a copy of this instance with the given \fImonth\fR of the year [1, 12] 
altered. The day of the month of the date is unchanged unless the day does not 
exist in the given month. In that case, the day is set to the last day of the 
given month.
.SS "with_week"
.IX Subsection "with_week"
.Vb 1
\&    $tm2 = $tm1\->with_week($week);
.Ve
.PP
Returns a copy of this instance with the given \fIweek\fR of the year [1, 53] 
altered. The week must be valid for the year, otherwise an exception is raised.
.SS "with_day_of_year"
.IX Subsection "with_day_of_year"
.Vb 1
\&    $tm2 = $tm1\->with_day_of_year($day);
.Ve
.PP
Returns a copy of this instance with the given \fIday\fR of the year [1, 366] 
altered. The day must be valid for the year, otherwise an exception is raised.
.SS "with_day_of_quarter"
.IX Subsection "with_day_of_quarter"
.Vb 1
\&    $tm2 = $tm1\->with_day_of_quarter($day);
.Ve
.PP
Returns a copy of this instance with the given \fIday\fR of the quarter [1, 92] 
altered. The day must be valid for the year and quarter, otherwise an 
exception is raised.
.SS "with_day_of_month"
.IX Subsection "with_day_of_month"
.Vb 1
\&    $tm2 = $tm1\->with_day_of_month($day);
.Ve
.PP
Returns a copy of this instance with the given \fIday\fR of the month [1, 31] 
altered. The day must be valid for the year and month, otherwise an exception 
is raised.
.SS "with_day_of_week"
.IX Subsection "with_day_of_week"
.Vb 1
\&    $tm2 = $tm1\->with_day_of_week($day);
.Ve
.PP
Returns a copy of this instance with the given \fIday\fR of the week 
[1=Monday, 7=Sunday] altered.
.SS "with_hour"
.IX Subsection "with_hour"
.Vb 1
\&    $tm2 = $tm1\->with_hour($hour);
.Ve
.PP
Returns a copy of this instance with the given \fIhour\fR of the day [0, 23] 
altered.
.SS "with_minute"
.IX Subsection "with_minute"
.Vb 1
\&    $tm2 = $tm1\->with_minute($minute);
.Ve
.PP
Returns a copy of this instance with the given \fIminute\fR of the hour [0, 59] 
altered.
.SS "with_minute_of_day"
.IX Subsection "with_minute_of_day"
.Vb 1
\&    $tm2 = $tm1\->with_minute_of_day($minute);
.Ve
.PP
Returns a copy of this instance with the given \fIminute\fR of the day [0, 1439] 
altered, any lower-order time elements is unaltered.
.SS "with_second"
.IX Subsection "with_second"
.Vb 1
\&    $tm2 = $tm1\->with_second($second);
.Ve
.PP
Returns a copy of this instance with the given \fIsecond\fR of the minute [0, 59] 
altered.
.SS "with_second_of_day"
.IX Subsection "with_second_of_day"
.Vb 1
\&    $tm2 = $tm1\->with_second_of_day($second);
.Ve
.PP
Returns a copy of this instance with the given \fIsecond\fR of the day [0, 86_399] 
altered, any lower-order time elements is unaltered.
.SS "with_millisecond"
.IX Subsection "with_millisecond"
.Vb 1
\&    $tm2 = $tm1\->with_millisecond($millisecond);
.Ve
.PP
Returns a copy of this instance with the given \fImillisecond\fR of the second 
[0, 999] altered. The nanosecond of the second is replaced with the given
\&\fImillisecond\fR multiplied by 1,000,000.
.SS "with_millisecond_of_day"
.IX Subsection "with_millisecond_of_day"
.Vb 1
\&    $tm2 = $tm1\->with_millisecond_of_day($millisecond);
.Ve
.PP
Returns a copy of this instance with the given \fImillisecond\fR of the day 
[0, 86_400_000] altered. A millisecond value of 86_400_000 (T24:00) is 
normalized to midnight of the following day, any lower-order time elements 
is truncated.
.SS "with_microsecond"
.IX Subsection "with_microsecond"
.Vb 1
\&    $tm2 = $tm1\->with_microsecond($microsecond);
.Ve
.PP
Returns a copy of this instance with the given \fImicrosecond\fR of the second 
[0, 999_999] altered. The nanosecond of the second is replaced with the given
\&\fImicrosecond\fR multiplied by 1,000.
.SS "with_microsecond_of_day"
.IX Subsection "with_microsecond_of_day"
.Vb 1
\&    $tm2 = $tm1\->with_microsecond_of_day($microsecond);
.Ve
.PP
Returns a copy of this instance with the given \fImicrosecond\fR of the day 
[0, 86_400_000_000] altered. A microsecond value of 86_400_000_000 (T24:00) 
is normalized to midnight of the following day, any lower-order time elements 
is truncated.
.SS "with_nanosecond"
.IX Subsection "with_nanosecond"
.Vb 1
\&    $tm2 = $tm1\->with_nanosecond($nanosecond);
.Ve
.PP
Returns a copy of this instance with the given \fInanosecond\fR of the second 
[0, 999_999_999] altered.
.SS "with_nanosecond_of_day"
.IX Subsection "with_nanosecond_of_day"
.Vb 1
\&    $tm2 = $tm1\->with_nanosecond_of_day($nanosecond);
.Ve
.PP
Returns a copy of this instance with the given \fInanosecond\fR of the day 
[0, 86_400_000_000_000] altered. A nanosecond value of 86_400_000_000_000 
(T24:00) is normalized to midnight of the following day.
.SS "with_offset_same_instant"
.IX Subsection "with_offset_same_instant"
.Vb 1
\&    $tm2 = $tm1\->with_offset_same_instant($offset);
.Ve
.PP
Returns a copy of this instance with the given \fIoffset\fR from \s-1UTC\s0 in 
minutes [\-1080, 1080] (±18:00) altered. The resulting time is at the same 
instant.
.PP
.Vb 3
\&    $tm = Time::Moment\->from_string(\*(Aq2012\-12\-24T15\-05\*(Aq)
\&                      \->with_offset_same_instant(0);
\&    say $tm; # 2012\-12\-24T20Z
.Ve
.SS "with_offset_same_local"
.IX Subsection "with_offset_same_local"
.Vb 1
\&    $tm2 = $tm1\->with_offset_same_local($offset);
.Ve
.PP
Returns a copy of this instance with the given \fIoffset\fR from \s-1UTC\s0 in 
minutes [\-1080, 1080] (±18:00) altered. The resulting time has the same 
local time.
.PP
.Vb 3
\&    $tm = Time::Moment\->from_string(\*(Aq2012\-12\-24T15\-05\*(Aq)
\&                      \->with_offset_same_local(0);
\&    say $tm; # 2012\-12\-24T15Z
.Ve
.SS "with_precision"
.IX Subsection "with_precision"
.Vb 1
\&    $tm2 = $tm1\->with_precision($precision);
.Ve
.PP
Returns a copy of this instance with the time of the day altered to the 
given \fIprecision\fR [\-3, 9]. A precision value between [0, 9] alters the 
precision of the fractional seconds. A precision of \f(CW\*(C`\-1\*(C'\fR truncates to 
minute of the hour; \f(CW\*(C`\-2\*(C'\fR truncates to hour of the day; \f(CW\*(C`\-3\*(C'\fR truncates 
to midnight of the day.
.PP
.Vb 7
\&    $tm = Time::Moment\->from_string(\*(Aq2012\-12\-24T12:30:45.123456789Z\*(Aq);
\&    say $tm\->with_precision(6);  # T12:30:45.123456Z
\&    say $tm\->with_precision(3);  # T12:30:45.123Z
\&    say $tm\->with_precision(0);  # T12:30:45Z
\&    say $tm\->with_precision(\-1); # T12:30:00Z
\&    say $tm\->with_precision(\-2); # T12:00:00Z
\&    say $tm\->with_precision(\-3); # T00:00:00Z
.Ve
.SS "plus_years"
.IX Subsection "plus_years"
.Vb 1
\&    $tm2 = $tm1\->plus_years($years);
.Ve
.PP
Returns a copy of this instance with the given number of \fIyears\fR added. The 
day of the month of the date is unchanged unless the day does not exist in the 
resulting month. In that case, the day is set to the last day of the resulting 
month. For example, 2012\-02\-29 plus one year results in 2013\-02\-28.
.SS "plus_months"
.IX Subsection "plus_months"
.Vb 1
\&    $tm2 = $tm1\->plus_months($months);
.Ve
.PP
Returns a copy of this instance with the given number of \fImonths\fR added. The 
day of the month of the date is unchanged unless the day does not exist in the 
resulting month. In that case, the day is set to the last day of the resulting 
month. For example, 2013\-01\-31 plus one month results in 2013\-02\-28; 
2013\-02\-28 plus one month results in 2013\-03\-28.
.SS "plus_weeks"
.IX Subsection "plus_weeks"
.Vb 1
\&    $tm2 = $tm1\->plus_weeks($weeks);
.Ve
.PP
Returns a copy of this instance with the given number of \fIweeks\fR added.
.SS "plus_days"
.IX Subsection "plus_days"
.Vb 1
\&    $tm2 = $tm1\->plus_days($days);
.Ve
.PP
Returns a copy of this instance with the given number of \fIdays\fR added.
.SS "plus_hours"
.IX Subsection "plus_hours"
.Vb 1
\&    $tm2 = $tm1\->plus_hours($hours);
.Ve
.PP
Returns a copy of this instance with the given number of \fIhours\fR added.
.SS "plus_minutes"
.IX Subsection "plus_minutes"
.Vb 1
\&    $tm2 = $tm1\->plus_minutes($minutes);
.Ve
.PP
Returns a copy of this instance with the given number of \fIminutes\fR added.
.SS "plus_seconds"
.IX Subsection "plus_seconds"
.Vb 1
\&    $tm2 = $tm1\->plus_seconds($seconds);
.Ve
.PP
Returns a copy of this instance with the given number of \fIseconds\fR added.
.SS "plus_milliseconds"
.IX Subsection "plus_milliseconds"
.Vb 1
\&    $tm2 = $tm1\->plus_milliseconds($milliseconds);
.Ve
.PP
Returns a copy of this instance with the given number of \fImilliseconds\fR 
added.
.SS "plus_microseconds"
.IX Subsection "plus_microseconds"
.Vb 1
\&    $tm2 = $tm1\->plus_microseconds($microseconds);
.Ve
.PP
Returns a copy of this instance with the given number of \fImicroseconds\fR 
added.
.SS "plus_nanoseconds"
.IX Subsection "plus_nanoseconds"
.Vb 1
\&    $tm2 = $tm1\->plus_nanoseconds($nanoeconds);
.Ve
.PP
Returns a copy of this instance with the given number of \fInanoseconds\fR 
added.
.SS "minus_years"
.IX Subsection "minus_years"
.Vb 1
\&    $tm2 = $tm1\->minus_years($years);
.Ve
.PP
Returns a copy of this instance with the given number of \fIyears\fR subtracted. 
The day of the month of the date is unchanged unless the day does not exist in 
the resulting month. In that case, the day is set to the last day of the 
resulting month. For example, 2012\-02\-29 minus one year results in 2011\-02\-28.
.SS "minus_months"
.IX Subsection "minus_months"
.Vb 1
\&    $tm2 = $tm1\->minus_months($months);
.Ve
.PP
Returns a copy of this instance with the given number of \fImonths\fR subtracted. 
The day of the month of the date is unchanged unless the day does not exist in 
the resulting month. In that case, the day is set to the last day of the 
resulting month. For example, 2013\-03\-31 minus one month results in 2013\-02\-28; 
2013\-02\-28 minus one month results in 2013\-01\-28.
.SS "minus_weeks"
.IX Subsection "minus_weeks"
.Vb 1
\&    $tm2 = $tm1\->minus_weeks($weeks);
.Ve
.PP
Returns a copy of this instance with the given number of \fIweeks\fR subtracted.
.SS "minus_days"
.IX Subsection "minus_days"
.Vb 1
\&    $tm2 = $tm1\->minus_days($days);
.Ve
.PP
Returns a copy of this instance with the given number of \fIdays\fR subtracted.
.SS "minus_hours"
.IX Subsection "minus_hours"
.Vb 1
\&    $tm2 = $tm1\->minus_hours($hours);
.Ve
.PP
Returns a copy of this instance with the given number of \fIhours\fR subtracted.
.SS "minus_minutes"
.IX Subsection "minus_minutes"
.Vb 1
\&    $tm2 = $tm1\->minus_minutes($minutes);
.Ve
.PP
Returns a copy of this instance with the given number of \fIminutes\fR subtracted.
.SS "minus_seconds"
.IX Subsection "minus_seconds"
.Vb 1
\&    $tm2 = $tm1\->minus_seconds($seconds);
.Ve
.PP
Returns a copy of this instance with the given number of \fIseconds\fR subtracted.
.SS "minus_milliseconds"
.IX Subsection "minus_milliseconds"
.Vb 1
\&    $tm2 = $tm1\->minus_milliseconds($milliseconds);
.Ve
.PP
Returns a copy of this instance with the given number of \fImilliseconds\fR 
subtracted.
.SS "minus_microseconds"
.IX Subsection "minus_microseconds"
.Vb 1
\&    $tm2 = $tm1\->minus_microseconds($microseconds);
.Ve
.PP
Returns a copy of this instance with the given number of \fImicroseconds\fR 
subtracted.
.SS "minus_nanoseconds"
.IX Subsection "minus_nanoseconds"
.Vb 1
\&    $tm2 = $tm1\->minus_nanoseconds($nanoseconds);
.Ve
.PP
Returns a copy of this instance with the given number of \fInanoseconds\fR 
subtracted.
.SS "delta_years"
.IX Subsection "delta_years"
.Vb 1
\&    $years = $tm\->delta_years($other);
.Ve
.PP
Returns the difference between the local date of this moment and the \fIother\fR 
in terms of complete years. The result will be negative if the local date of 
the \fIother\fR moment is before this.
.SS "delta_months"
.IX Subsection "delta_months"
.Vb 1
\&    $months = $tm\->delta_months($other);
.Ve
.PP
Returns the difference between the local date of this moment and the \fIother\fR 
in terms of complete months. The result will be negative if the local date of 
the \fIother\fR moment is before this.
.SS "delta_weeks"
.IX Subsection "delta_weeks"
.Vb 1
\&    $weeks = $tm\->delta_weeks($other);
.Ve
.PP
Returns the difference between the local date of this moment and the \fIother\fR 
in terms of complete weeks. The result will be negative if the local date of 
the \fIother\fR moment is before this.
.SS "delta_days"
.IX Subsection "delta_days"
.Vb 1
\&    $days = $tm\->delta_days($other);
.Ve
.PP
Returns the difference between the local date of this moment and the \fIother\fR 
in terms of complete days. The result will be negative if the local date of 
the \fIother\fR moment is before this.
.SS "delta_hours"
.IX Subsection "delta_hours"
.Vb 1
\&    $hours = $tm\->delta_hours($other);
.Ve
.PP
Returns the difference between the instant of this moment and the \fIother\fR 
in terms of complete hours. The result will be negative if the instant of 
the \fIother\fR moment is before this.
.SS "delta_minutes"
.IX Subsection "delta_minutes"
.Vb 1
\&    $minutes = $tm\->delta_minutes($other);
.Ve
.PP
Returns the difference between the instant of this moment and the \fIother\fR 
in terms of complete minutes. The result will be negative if the instant of 
the \fIother\fR moment is before this.
.SS "delta_seconds"
.IX Subsection "delta_seconds"
.Vb 1
\&    $seconds = $tm\->delta_seconds($other);
.Ve
.PP
Returns the difference between the instant of this moment and the \fIother\fR in 
terms of complete seconds. The result will be negative if the instant of the 
\&\fIother\fR moment is before this.
.SS "delta_milliseconds"
.IX Subsection "delta_milliseconds"
.Vb 1
\&    $milliseconds = $tm\->delta_milliseconds($other);
.Ve
.PP
Returns the difference between the instant of this moment and the \fIother\fR in 
terms of complete milliseconds. The result will be negative if the instant of 
the \fIother\fR moment is before this.
.SS "delta_microseconds"
.IX Subsection "delta_microseconds"
.Vb 1
\&    $microseconds = $tm\->delta_microseconds($other);
.Ve
.PP
Returns the difference between the instant of this moment and the \fIother\fR in 
terms of complete microseconds. The result will be negative if the instant of 
the \fIother\fR moment is before this.
.SS "delta_nanoseconds"
.IX Subsection "delta_nanoseconds"
.Vb 1
\&    $nanoseconds = $tm\->delta_nanoseconds($other);
.Ve
.PP
Returns the difference between the instant of this moment and the \fIother\fR in 
terms of complete nanoseconds. The result will be negative if the instant of 
the \fIother\fR moment is before this.
.SS "at_utc"
.IX Subsection "at_utc"
.Vb 1
\&    $tm2 = $tm1\->at_utc;
.Ve
.PP
Returns a copy of this instance with the offset from \s-1UTC\s0 set to zero. This 
method is equivalent to:
.PP
.Vb 1
\&    $tm2 = $tm1\->with_offset_same_instant(0);
.Ve
.SS "at_midnight"
.IX Subsection "at_midnight"
.Vb 1
\&    $tm2 = $tm1\->at_midnight;
.Ve
.PP
Returns a copy of this instance with the time of day set to midnight, 
T00:00:00.0. This method is equivalent to:
.PP
.Vb 4
\&    $tm2 = $tm1\->with_hour(0)
\&               \->with_minute(0)
\&               \->with_second(0)
\&               \->with_nanosecond(0);
.Ve
.SS "at_noon"
.IX Subsection "at_noon"
.Vb 1
\&    $tm2 = $tm1\->at_noon;
.Ve
.PP
Returns a copy of this instance with the time of day set to noon, 
T12:00:00.0. This method is equivalent to:
.PP
.Vb 4
\&    $tm2 = $tm1\->with_hour(12)
\&               \->with_minute(0)
\&               \->with_second(0)
\&               \->with_nanosecond(0);
.Ve
.SS "at_last_day_of_year"
.IX Subsection "at_last_day_of_year"
.Vb 1
\&    $tm2 = $tm1\->at_last_day_of_year;
.Ve
.PP
Returns a copy of this instance with the date adjusted to the last day of 
the year, the time of the day is unaltered.
.SS "at_last_day_of_quarter"
.IX Subsection "at_last_day_of_quarter"
.Vb 1
\&    $tm2 = $tm1\->at_last_day_of_quarter;
.Ve
.PP
Returns a copy of this instance with the date adjusted to the last day of 
the quarter, the time of the day is unaltered.
.SS "at_last_day_of_month"
.IX Subsection "at_last_day_of_month"
.Vb 1
\&    $tm2 = $tm1\->at_last_day_of_month;
.Ve
.PP
Returns a copy of this instance with the date adjusted to the last day of 
the month, the time of the day is unaltered.
.SS "is_before"
.IX Subsection "is_before"
.Vb 1
\&    $boolean = $tm\->is_before($other);
.Ve
.PP
Returns a boolean indicating whether or not the instant of this time is before 
the \fIother\fR time.
.SS "is_after"
.IX Subsection "is_after"
.Vb 1
\&    $boolean = $tm\->is_after($other);
.Ve
.PP
Returns a boolean indicating whether or not the instant of this time is after 
the \fIother\fR time.
.SS "is_equal"
.IX Subsection "is_equal"
.Vb 1
\&    $boolean = $tm\->is_equal($other);
.Ve
.PP
Returns a boolean indicating whether or not the instant of this time is equal 
the \fIother\fR time.
.SS "compare"
.IX Subsection "compare"
.Vb 2
\&    $integer = $tm\->compare($other);
\&    $integer = $tm\->compare($other [, precision => 9]);
.Ve
.PP
Returns an integer indicating whether the instant of this time is before, 
after or equal the \fIother\fR time. Returns a value less than zero if this 
time is before the other; zero if this date is equal the other time; a value 
greater than zero if this time is after the other time. The optional parameter
\&\fIprecision\fR [\-3, 9] specifies the precision of the comparison. The default 
precision is 9 (nanoseconds). Please see with_precision 
for an explanation of the precision value.
.SS "is_leap_year"
.IX Subsection "is_leap_year"
.Vb 1
\&    $boolean = $tm\->is_leap_year;
.Ve
.PP
Returns a boolean indicating whether or not the year of the local date of 
this moment is a leap year.
.SS "to_string"
.IX Subsection "to_string"
.Vb 2
\&    $string = $tm\->to_string;
\&    $string = $tm\->to_string([reduced => false]);
.Ve
.PP
Returns a string representation of the instance. If the optional named 
boolean parameter \fIreduced\fR is true a shorter representation is attempted.
.PP
The string will be in one of the following representations:
.PP
.Vb 5
\&    YYYY\-MM\-DDThh:mm                (only if reduced => true)
\&    YYYY\-MM\-DDThh:mm:ss
\&    YYYY\-MM\-DDThh:mm:ss.fff
\&    YYYY\-MM\-DDThh:mm:ss.ffffff
\&    YYYY\-MM\-DDThh:mm:ss.fffffffff
.Ve
.PP
Followed by a zone designator in one of the following representations:
.PP
.Vb 3
\&    Z
\&    ±hh                             (only if reduced => true)
\&    ±hh:mm
.Ve
.PP
The shortest representation will be used where the omitted parts are implied 
to be zero.
.SS "strftime"
.IX Subsection "strftime"
.Vb 1
\&    $string = $tm\->strftime($format);
.Ve
.PP
Formats time according to the conversion specifications in the given \f(CW$format\fR
string. The format string consists of zero or more conversion specifications 
and ordinary characters. All ordinary characters are copied directly into the 
resulting string. A conversion specification consists of a percent sign \f(CW\*(C`%\*(C'\fR 
and one other character.
.PP
The following conversion specifications are supported:
.ie n .IP "%a" 4
.el .IP "\f(CW%a\fR" 4
.IX Item "%a"
Replaced by the C locale's abbreviated day of the week name. 
Example: Mon, Tue, ..., Sun.
.ie n .IP "%A" 4
.el .IP "\f(CW%A\fR" 4
.IX Item "%A"
Replaced by the C locale's full day of the week name.
Example: Monday, Tuesday, ..., Sunday.
.ie n .IP "%b" 4
.el .IP "\f(CW%b\fR" 4
.IX Item "%b"
Replaced by the C locale's abbreviated month name.
Example: Jan, Feb, ..., Dec.
.ie n .IP "%B" 4
.el .IP "\f(CW%B\fR" 4
.IX Item "%B"
Replaced by the C locale's full month name.
Example: January, February, ..., December.
.ie n .IP "%c" 4
.el .IP "\f(CW%c\fR" 4
.IX Item "%c"
Replaced by the C locale's date and time representation. 
Equivalent to \f(CW"%a %b %e %H:%M:%S %Y"\fR.
.ie n .IP "%C" 4
.el .IP "\f(CW%C\fR" 4
.IX Item "%C"
Replaced by the year divided by 100 and truncated to an integer, as a 
decimal number [00, 99].
.ie n .IP "%d" 4
.el .IP "\f(CW%d\fR" 4
.IX Item "%d"
Replaced by the day of the month as a decimal number [01, 31].
.ie n .IP "%D" 4
.el .IP "\f(CW%D\fR" 4
.IX Item "%D"
Equivalent to \f(CW"%m/%d/%y"\fR.
.ie n .IP "%e" 4
.el .IP "\f(CW%e\fR" 4
.IX Item "%e"
Replaced by the day of the month as a decimal number [1, 31]; 
a single digit is preceded by a space.
.ie n .IP "%f" 4
.el .IP "\f(CW%f\fR" 4
.IX Item "%f"
Replaced by the fractional second including the preceding decimal point or 
by an empty string if no fractional seconds are present. This conversion 
specification permits use of an optional maximum field width [0, 9] where 
the default field width of 0 will use the shortest of the following 
representations:
.Sp
.Vb 3
\&    .fff        (millisecond)
\&    .ffffff     (microsecond)
\&    .fffffffff  (nanosecond)
.Ve
.Sp
Example:
.Sp
.Vb 4
\&    $tm = Time::Moment\->from_string(\*(Aq2012\-12\-24T15:30:45.123456Z\*(Aq);
\&    $tm\->strftime(\*(Aq%f\*(Aq);    # \*(Aq.123456\*(Aq
\&    $tm\->strftime(\*(Aq%3f\*(Aq);   # \*(Aq.123\*(Aq
\&    $tm\->strftime(\*(Aq%9f\*(Aq);   # \*(Aq.123456000\*(Aq
\&    
\&    $tm = Time::Moment\->from_string(\*(Aq2012\-12\-24T15:30:45Z\*(Aq);
\&    $tm\->strftime(\*(Aq%f\*(Aq);    # \*(Aq\*(Aq
\&    $tm\->strftime(\*(Aq%3f\*(Aq);   # \*(Aq\*(Aq
.Ve
.Sp
\&\f(CW%3f\fR is replaced by decimal point and exactly three fractional digits 
(zero-padded on the right or truncated if needed) if fractional seconds 
are present.
.Sp
\&\fIThis conversion specification is an extension to the 
\&\*(L"\s-1IEEE\s0 Std 1003.1\*(R" <http://pubs.opengroup.org/onlinepubs/9699919799/functions/strftime.html>\fR.
.ie n .IP "%F" 4
.el .IP "\f(CW%F\fR" 4
.IX Item "%F"
Equivalent to \f(CW"%Y\-%m\-%d"\fR.
.ie n .IP "%g" 4
.el .IP "\f(CW%g\fR" 4
.IX Item "%g"
Replaced by the last 2 digits of the year of the week as a decimal 
number [00, 99].
.ie n .IP "%G" 4
.el .IP "\f(CW%G\fR" 4
.IX Item "%G"
Replaced by the week-based year as a decimal number [0001, 9999].
.ie n .IP "%h" 4
.el .IP "\f(CW%h\fR" 4
.IX Item "%h"
Equivalent to \f(CW%b\fR.
.ie n .IP "%H" 4
.el .IP "\f(CW%H\fR" 4
.IX Item "%H"
Replaced by the hour of day (24\-hour clock) as a decimal number [00, 23].
.ie n .IP "%I" 4
.el .IP "\f(CW%I\fR" 4
.IX Item "%I"
Replaced by the hour of day (12\-hour clock) as a decimal number [01, 12].
.ie n .IP "%j" 4
.el .IP "\f(CW%j\fR" 4
.IX Item "%j"
Replaced by the day of the year as a decimal number [001, 366].
.ie n .IP "%k" 4
.el .IP "\f(CW%k\fR" 4
.IX Item "%k"
Replaced by the hour of day (24\-hour clock) as a decimal number [1, 23]; 
a single digit is preceded by a space.
.Sp
\&\fIThis conversion specification is an extension to the 
\&\*(L"\s-1IEEE\s0 Std 1003.1\*(R" <http://pubs.opengroup.org/onlinepubs/9699919799/functions/strftime.html>\fR.
.ie n .IP "%l" 4
.el .IP "\f(CW%l\fR" 4
.IX Item "%l"
Replaced by the hour of day (12\-hour clock) as a decimal number [1, 12]; 
a single digit is preceded by a space.
.Sp
\&\fIThis conversion specification is an extension to the 
\&\*(L"\s-1IEEE\s0 Std 1003.1\*(R" <http://pubs.opengroup.org/onlinepubs/9699919799/functions/strftime.html>\fR.
.ie n .IP "%m" 4
.el .IP "\f(CW%m\fR" 4
.IX Item "%m"
Replaced by the month of the year as a decimal number [01, 12].
.ie n .IP "%M" 4
.el .IP "\f(CW%M\fR" 4
.IX Item "%M"
Replaced by the minute of hour as a decimal number [00, 59].
.ie n .IP "%n" 4
.el .IP "\f(CW%n\fR" 4
.IX Item "%n"
Replaced by a <newline> character.
.ie n .IP "%N" 4
.el .IP "\f(CW%N\fR" 4
.IX Item "%N"
Replaced by the fractional second as a decimal number. This conversion 
specification permits use of an optional maximum field width [0, 9] where 
the default field width of 0 will use the shortest of the following 
representations:
.Sp
.Vb 3
\&    fff        (millisecond)
\&    ffffff     (microsecond)
\&    fffffffff  (nanosecond)
.Ve
.Sp
Example:
.Sp
.Vb 4
\&    $tm = Time::Moment\->from_string(\*(Aq2012\-12\-24T15:30:45.123456Z\*(Aq);
\&    $tm\->strftime(\*(Aq%N\*(Aq);    # \*(Aq123456\*(Aq
\&    $tm\->strftime(\*(Aq%3N\*(Aq);   # \*(Aq123\*(Aq
\&    $tm\->strftime(\*(Aq%9N\*(Aq);   # \*(Aq123456000\*(Aq
.Ve
.Sp
\&\f(CW%3N\fR is replaced by exactly three fractional digits (zero-padded on the 
right or truncated if needed).
.Sp
\&\fIThis conversion specification is an extension to the 
\&\*(L"\s-1IEEE\s0 Std 1003.1\*(R" <http://pubs.opengroup.org/onlinepubs/9699919799/functions/strftime.html>\fR.
.ie n .IP "%p" 4
.el .IP "\f(CW%p\fR" 4
.IX Item "%p"
Replaced by the C locale's meridian notation. Example: \s-1AM, PM.\s0
.ie n .IP "%r" 4
.el .IP "\f(CW%r\fR" 4
.IX Item "%r"
Replaced by the C locale's time in a.m. and p.m. notation. Equivalent 
to \f(CW"%I:%M:%S %p"\fR.
.ie n .IP "%R" 4
.el .IP "\f(CW%R\fR" 4
.IX Item "%R"
Replaced by the time in 24\-hour notation. Equivalent to \f(CW"%H:%M"\fR.
.ie n .IP "%s" 4
.el .IP "\f(CW%s\fR" 4
.IX Item "%s"
Replaced by the number of seconds from the epoch of 1970\-01\-01T00:00:00Z 
as a decimal number.
.Sp
\&\fIThis conversion specification is an extension to the 
\&\*(L"\s-1IEEE\s0 Std 1003.1\*(R" <http://pubs.opengroup.org/onlinepubs/9699919799/functions/strftime.html>\fR.
.ie n .IP "%S" 4
.el .IP "\f(CW%S\fR" 4
.IX Item "%S"
Replaced by the second of hour as a decimal number [00, 59].
.ie n .IP "%t" 4
.el .IP "\f(CW%t\fR" 4
.IX Item "%t"
Replaced by a <tab> character.
.ie n .IP "%T" 4
.el .IP "\f(CW%T\fR" 4
.IX Item "%T"
Replaced by the time of day. Equivalent to \f(CW"%H:%M:%S"\fR.
.ie n .IP "%u" 4
.el .IP "\f(CW%u\fR" 4
.IX Item "%u"
Replaced by the day of the week as a decimal number [1, 7], with 1 
representing Monday.
.ie n .IP "%U" 4
.el .IP "\f(CW%U\fR" 4
.IX Item "%U"
Replaced by the week number of the year as a decimal number [00, 53]. The 
first Sunday of January is the first day of week 1; days in the new year 
before this are in week 0.
.ie n .IP "%V" 4
.el .IP "\f(CW%V\fR" 4
.IX Item "%V"
Replaced by the week number of the year (Monday as the first day of the week) 
as a decimal number [01, 53]. If the week containing 1 January has four or 
more days in the new year, then it is considered week 1. Otherwise, it is the 
last week of the previous year, and the next week is week 1. Both January 4th 
and the first Thursday of January are always in week 1.
.ie n .IP "%w" 4
.el .IP "\f(CW%w\fR" 4
.IX Item "%w"
Replaced by the day of the week as a decimal number [0, 6], with 0 
representing Sunday.
.ie n .IP "%W" 4
.el .IP "\f(CW%W\fR" 4
.IX Item "%W"
Replaced by the week number of the year as a decimal number [00, 53]. The 
first Monday of January is the first day of week 1; days in the new year 
before this are in week 0.
.ie n .IP "%x" 4
.el .IP "\f(CW%x\fR" 4
.IX Item "%x"
Replaced by the C locale's date representation. Equivalent to \f(CW"%m/%d/%y"\fR.
.ie n .IP "%X" 4
.el .IP "\f(CW%X\fR" 4
.IX Item "%X"
Replaced by the C locale's time representation. Equivalent to \f(CW"%H:%M:%S"\fR.
.ie n .IP "%y" 4
.el .IP "\f(CW%y\fR" 4
.IX Item "%y"
Replaced by the last two digits of the year as a decimal number [00, 99].
.ie n .IP "%Y" 4
.el .IP "\f(CW%Y\fR" 4
.IX Item "%Y"
Replaced by the year as a decimal number [0001, 9999].
.ie n .IP "%z" 4
.el .IP "\f(CW%z\fR" 4
.IX Item "%z"
Replaced by the offset from \s-1UTC\s0 in the \s-1ISO 8601\s0 basic format (±hhmm).
.ie n .IP "%:z" 4
.el .IP "\f(CW%:z\fR" 4
.IX Item "%:z"
Replaced by the offset from \s-1UTC\s0 in the \s-1ISO 8601\s0 extended format (±hh:mm).
.ie n .IP "%Z" 4
.el .IP "\f(CW%Z\fR" 4
.IX Item "%Z"
Replaced by the offset from \s-1UTC\s0 in the \s-1ISO 8601\s0 extended format or by \s-1UTC\s0 
designator (±hh:mm or Z).
.ie n .IP """%%""" 4
.el .IP "\f(CW%%\fR" 4
.IX Item "%%"
Replaced by %.
.SS "length_of_year"
.IX Subsection "length_of_year"
.Vb 1
\&    $integer = $tm\->length_of_year;
.Ve
.PP
Returns the length of the year in days [365, 366].
.SS "length_of_quarter"
.IX Subsection "length_of_quarter"
.Vb 1
\&    $integer = $tm\->length_of_quarter;
.Ve
.PP
Returns the length of the quarter of the year in days [90, 92].
.SS "length_of_month"
.IX Subsection "length_of_month"
.Vb 1
\&    $integer = $tm\->length_of_month;
.Ve
.PP
Returns the length of the month of the year in days [28, 31].
.SS "length_of_week_year"
.IX Subsection "length_of_week_year"
.Vb 1
\&    $integer = $tm\->length_of_week_year;
.Ve
.PP
Returns the length of the week of the year in weeks [52, 53].
.SS "utc_rd_values"
.IX Subsection "utc_rd_values"
.Vb 1
\&    ($rdn, $sod, $nanosecond) = $tm\->utc_rd_values;
.Ve
.PP
Returns a list of three elements:
.ie n .IP "$rdn" 4
.el .IP "\f(CW$rdn\fR" 4
.IX Item "$rdn"
The number of integral days from the Rata Die epoch of 0000\-12\-31.
.ie n .IP "$sod" 4
.el .IP "\f(CW$sod\fR" 4
.IX Item "$sod"
The second of the day [0, 86_399].
.ie n .IP "$nanosecond" 4
.el .IP "\f(CW$nanosecond\fR" 4
.IX Item "$nanosecond"
The nanosecond of the second [0, 999_999_999].
.SS "utc_rd_as_seconds"
.IX Subsection "utc_rd_as_seconds"
.Vb 1
\&    $seconds = $tm\->utc_rd_as_seconds;
.Ve
.PP
Returns the number of integral seconds from the Rata Die epoch of 
0000\-12\-31T00:00:00Z.
.SS "local_rd_values"
.IX Subsection "local_rd_values"
.Vb 1
\&    ($rdn, $sod, $nanosecond) = $tm\->local_rd_values;
.Ve
.PP
Returns a list of three elements:
.ie n .IP "$rdn" 4
.el .IP "\f(CW$rdn\fR" 4
.IX Item "$rdn"
The number of integral days from the Rata Die epoch of 0000\-12\-31.
.ie n .IP "$sod" 4
.el .IP "\f(CW$sod\fR" 4
.IX Item "$sod"
The second of the day [0, 86_399].
.ie n .IP "$nanosecond" 4
.el .IP "\f(CW$nanosecond\fR" 4
.IX Item "$nanosecond"
The nanosecond of the second [0, 999_999_999].
.SS "local_rd_as_seconds"
.IX Subsection "local_rd_as_seconds"
.Vb 1
\&    $seconds = $tm\->local_rd_as_seconds;
.Ve
.PP
Returns the number of integral seconds from the Rata Die epoch of 
0000\-12\-31T00:00:00.
.SH "OVERLOADED OPERATORS"
.IX Header "OVERLOADED OPERATORS"
.SS "stringification"
.IX Subsection "stringification"
.Vb 1
\&    $string = "$tm";
.Ve
.PP
The \f(CW$string\fR will be in one of the following representations:
.PP
.Vb 4
\&    YYYY\-MM\-DDThh:mm:ss
\&    YYYY\-MM\-DDThh:mm:ss.fff
\&    YYYY\-MM\-DDThh:mm:ss.ffffff
\&    YYYY\-MM\-DDThh:mm:ss.fffffffff
.Ve
.PP
Followed by a zone designator in one of the following representations:
.PP
.Vb 2
\&    Z
\&    ±hh:mm
.Ve
.PP
The shortest representation will be used where the omitted parts are implied 
to be zero. This representation is conformant with \s-1ISO 8601\s0 profiles, such as:
.IP "\(bu" 4
\&\s-1RFC 3339\s0 Date and Time on the Internet: Timestamps <http://tools.ietf.org/html/rfc3339>
.IP "\(bu" 4
\&\s-1RFC 4287\s0 The Atom Syndication Format <http://tools.ietf.org/html/rfc4287#section-3.3>
.IP "\(bu" 4
W3C Date and Time Formats <http://www.w3.org/TR/NOTE-datetime>
.IP "\(bu" 4
\&\s-1HTML5\s0 <http://www.w3.org/TR/html5/infrastructure.html#global-dates-and-times>
.IP "\(bu" 4
\&\s-1XML\s0 Schema <http://www.w3.org/TR/xmlschema-2/#dateTime>
.PP
The \f(CW\*(C`to_string\*(C'\fR method or the \f(CW\*(C`strftime\*(C'\fR format string \f(CW"%Y\-%m\-%dT%H:%M:%S%f%Z"\fR 
produces an equivalent string representation:
.PP
.Vb 2
\&    "$tm" eq $tm\->to_string;
\&    "$tm" eq $tm\->strftime("%Y\-%m\-%dT%H:%M:%S%f%Z");
.Ve
.PP
The total length of the string representation will be between 20 and 35 
characters (inclusive).
.SS "comparison"
.IX Subsection "comparison"
.Vb 1
\&    $integer      = $tm1 <=> $tm2;
\&    
\&    $boolean      = $tm1 == $tm2;
\&    $boolean      = $tm1 != $tm2;
\&    $boolean      = $tm1 <  $tm2;
\&    $boolean      = $tm1 >  $tm2;
\&    $boolean      = $tm1 <= $tm2;
\&    $boolean      = $tm1 >= $tm2;
.Ve
.SH "SERIALIZATION"
.IX Header "SERIALIZATION"
.SS "Storable"
.IX Subsection "Storable"
The serialized representation of a \f(CW\*(C`Time::Moment\*(C'\fR is a string of 16 bytes that 
contains \s-1MAGIC\s0 (2 bytes), time zone offset from \s-1UTC\s0 (2 bytes), the number 
of days from Rata Die (4 bytes), second of the day (4 bytes) and nanosecond of 
the second (4 bytes).
.PP
The total size of the serialized \f(CW\*(C`Time::Moment\*(C'\fR instance using \f(CW\*(C`nfreeze\*(C'\fR is 
34 bytes.
.SS "\s-1JSON\s0"
.IX Subsection "JSON"
\&\f(CW\*(C`Time::Moment\*(C'\fR implements a \f(CW\*(C`TO_JSON\*(C'\fR method that returns the stringified
representation of the instance.
.SS "\s-1CBOR\s0"
.IX Subsection "CBOR"
\&\f(CW\*(C`Time::Moment\*(C'\fR implements a \f(CW\*(C`TO_CBOR\*(C'\fR method that returns the stringified
representation of the instance using tag \f(CW0\fR (\fIstandard date/time string\fR).
.PP
See \s-1CBOR::XS\s0, \s-1RFC 7049\s0 Section 2.4.1 <http://tools.ietf.org/html/rfc7049#section-2.4.1>
and \f(CW\*(C`eg/cbor.pl\*(C'\fR for an example how to roundtrip instances of \f(CW\*(C`Time::Moment\*(C'\fR.
.SS "Sereal"
.IX Subsection "Sereal"
Sereal version 2.030 or later implements support for the generic serialization 
protocol \f(CW\*(C`FREEZE/THAW\*(C'\fR.
.SS "\s-1FREEZE/THAW\s0"
.IX Subsection "FREEZE/THAW"
\&\f(CW\*(C`Time::Moment\*(C'\fR implements a \f(CW\*(C`FREEZE\*(C'\fR method that returns the stringified
representation of the instance and a \f(CW\*(C`THAW\*(C'\fR method according to the serialization 
protocol specified in Types::Serialiser.
.SH "EXAMPLE FORMAT STRINGS"
.IX Header "EXAMPLE FORMAT STRINGS"
.SS "\s-1ISO 8601\s0 \- Data elements and interchange formats"
.IX Subsection "ISO 8601 - Data elements and interchange formats"
\fIDate\fR
.IX Subsection "Date"
.PP
Calendar date \- 24 December 2012
.PP
.Vb 3
\&    Basic format:               Example:
\&    %Y%m%d                      20121224
\&    %y%m                        201212      (reduced accuracy)
\&
\&    Extended format:            Example:
\&    %Y\-%m\-%d                    2012\-12\-24
\&    %Y\-%m                       2012\-12     (reduced accuracy)
.Ve
.PP
Ordinal date \- 24 December 2012
.PP
.Vb 2
\&    Basic format:               Example:
\&    %Y%j                        2012359
\&    
\&    Extended format:            Example:
\&    %Y\-%j                       2012\-359
.Ve
.PP
Week date \- Monday, 24 December 2012
.PP
.Vb 3
\&    Basic format:               Example:
\&    %GW%V%u                     2012W521
\&    %GW%V                       2012W52     (reduced accuracy)
\&
\&    Extended format:            Example:
\&    %G\-W%V\-%u                   2012\-W52\-1
\&    %G\-W%V                      2012\-W52    (reduced accuracy)
.Ve
.PP
\fITime of day\fR
.IX Subsection "Time of day"
.PP
Local time \- 30 minutes and 45 seconds past 15 hours
.PP
.Vb 3
\&    Basic format:               Example:
\&    %H%M%S                      153045
\&    %H%M                        1530        (reduced accuracy)
\&
\&    Extended format:            Example:
\&    %H:%M:%S                    15:30:45
\&    %H:%M                       15:30       (reduced accuracy)
.Ve
.PP
Local time with decimal fractions \- 30 minutes and 45 and a half second 
past 15 hours
.PP
.Vb 3
\&    Basic format:               Example:
\&    %H%M%S%f                    153045.500
\&    %H%M%S.%1N                  153045.5
\&
\&    Extended format:            Example:
\&    %H:%M:%S%f                  15:30:45.500
\&    %H:%M:%S.%1N                15:30:45.5
.Ve
.PP
Local time and the difference from \s-1UTC\s0 \- 30 minutes and 45 seconds past 
15 hours, one hour ahead of \s-1UTC\s0
.PP
.Vb 2
\&    Basic format:               Example:
\&    %H%M%S%z                    153045+0100
\&
\&    Extended format:            Example:
\&    %H:%M:%S%Z                  15:30:45+01:00
.Ve
.PP
\fIDate and time of day\fR
.IX Subsection "Date and time of day"
.PP
Combinations of calendar date and time of day
.PP
.Vb 4
\&    Basic format:               Example:
\&    %Y%m%dT%H%M%S%z             20121224T153045+0100
\&    %Y%m%dT%H%M%S%f%z           20121224T153045.500+0100
\&    %Y%m%dT%H%M%z               20121224T1530+0100      (reduced accuracy)
\&
\&    Extended format:            Example:
\&    %Y\-%m\-%dT%H:%M:%S%Z         2012\-12\-24T15:30:45+01:00
\&    %Y\-%m\-%dT%H:%M:%S%f%Z       2012\-12\-24T15:30:45.500+01:00
\&    %Y\-%m\-%dT%H:%M%Z            2012\-12\-24T15:30+01:00  (reduced accuracy)
.Ve
.PP
Combinations of ordinal date and time of day
.PP
.Vb 4
\&    Basic format:               Example:
\&    %Y%jT%H%M%S%z               2012359T153045+0100
\&    %Y%jT%H%M%S%f%z             2012359T153045.500+0100
\&    %Y%jT%H%M%z                 2012359T1530+0100       (reduced accuracy)
\&
\&    Extended format:            Example:
\&    %Y\-%jT%H:%M:%S%Z            2012\-359T15:30:45+01:00
\&    %Y\-%jT%H:%M:%S%f%Z          2012\-359T15:30:45.500+01:00
\&    %Y\-%jT%H:%M%Z               2012\-359T15:30+01:00    (reduced accuracy)
.Ve
.PP
Combinations of week date and time of day
.PP
.Vb 4
\&    Basic format:               Example:
\&    %GW%V%uT%H%M%S%z            2012W521T153045+0100
\&    %GW%V%uT%H%M%S%f%z          2012W521T153045.500+0100
\&    %GW%V%uT%H%M%f%z            2012W521T1530+0100      (reduced accuracy)
\&
\&    Extended format:            Example:
\&    %G\-W%V\-%uT%H:%M:%S%Z        2012\-W52\-1T15:30:45+01:00
\&    %G\-W%V\-%uT%H:%M:%S%f%Z      2012\-W52\-1T15:30:45.500+01:00
\&    %G\-W%V\-%uT%H:%M%Z           2012\-W52\-1T15:30+01:00  (reduced accuracy)
.Ve
.SS "\s-1ISO 9075\s0 \- Information technology \- Database languages \- \s-1SQL\s0"
.IX Subsection "ISO 9075 - Information technology - Database languages - SQL"
Literal values from Part 2: Foundation (SQL/Foundation)
.PP
.Vb 2
\&    Date:                       Example:
\&    %Y\-%m\-%d                    2012\-12\-24
\&    
\&    Time:                       Example:
\&    %H:%M:%S                    15:30:45
\&    %H:%M:%S%f                  15:30:45.500
\&    
\&    Timestamp:                  Example:
\&    %Y\-%m\-%d %H:%M:%S           2012\-12\-24 15:30:45
\&    %Y\-%m\-%d %H:%M:%S %:z       2012\-12\-24 15:30:45 +01:00
\&    %Y\-%m\-%d %H:%M:%S%f         2012\-12\-24 15:30:45.500
\&    %Y\-%m\-%d %H:%M:%S%f %:z     2012\-12\-24 15:30:45.500 +01:00
.Ve
.SS "\s-1RFC 1123\s0 \- Requirements for Internet Hosts"
.IX Subsection "RFC 1123 - Requirements for Internet Hosts"
\&\s-1RFC 822\s0 <http://tools.ietf.org/html/rfc822#section-5> as updated by 
\&\s-1RFC 1123\s0 <http://tools.ietf.org/html/rfc1123>.
.PP
.Vb 2
\&    Format:                     Example:
\&    %a, %d %b %Y %H:%M:%S %z    Mon, 24 Dec 2012 15:30:45 +0100
.Ve
.SS "\s-1RFC 2616\s0 \- \s-1HTTP/1.1\s0"
.IX Subsection "RFC 2616 - HTTP/1.1"
\&\s-1RFC 2616\s0 \- 3.3.1 Full Date <http://tools.ietf.org/html/rfc2616#section-3.3.1>.
.PP
.Vb 2
\&    Format:                     Example:
\&    %a, %d %b %Y %H:%M:%S GMT   Mon, 24 Dec 2012 14:30:45 GMT
.Ve
.PP
An \s-1HTTP\s0 date value represents time as an instance of \s-1UTC:\s0
.PP
.Vb 1
\&    $string = $tm\->at_utc\->strftime("%a, %d %b %Y %H:%M:%S GMT");
.Ve
.SS "\s-1RFC 5322\s0 \- Internet Message Format"
.IX Subsection "RFC 5322 - Internet Message Format"
\&\s-1RFC 5322\s0 \- 3.3. Date and Time Specification <http://tools.ietf.org/html/rfc5322#section-3.3>.
.PP
.Vb 5
\&    Format:                     Example:
\&    %a, %d %b %Y %H:%M:%S %z    Mon, 24 Dec 2012 15:30:45 +0100
\&    %a, %d %b %Y %H:%M %z       Mon, 24 Dec 2012 15:30 +0100
\&    %d %b %Y %H:%M:%S %z        24 Dec 2012 15:30:45 +0100
\&    %d %b %Y %H:%M %z           24 Dec 2012 15:30 +0100
.Ve
.SH "TIME ZONES"
.IX Header "TIME ZONES"
An instance of \f(CW\*(C`Time::Moment\*(C'\fR represents an unambiguous point in time, 
but it's not time zone aware. When performing arithmetic on the local 
date/time or altering the components of the local date/time it may be 
necessary to use a time zone to convert to the correct representation.
.PP
\&\f(CW\*(C`Time::Moment\*(C'\fR is \s-1API\s0 compatible with DateTime::TimeZone and 
DateTime::TimeZone::Tzfile.
.SS "Converting from instant time to designated time zone"
.IX Subsection "Converting from instant time to designated time zone"
.Vb 8
\&    $tm = Time::Moment\->new(
\&        year   => 2012,
\&        month  => 12,
\&        day    => 24,
\&        hour   => 15
\&    );
\&    $zone   = DateTime::TimeZone\->new(name => \*(AqAmerica/New_York\*(Aq);
\&    $offset = $zone\->offset_for_datetime($tm) / 60;
\&    
\&    say $tm\->with_offset_same_instant($offset); # 2012\-12\-24T10\-05
.Ve
.SS "Converting from local time to designated time zone"
.IX Subsection "Converting from local time to designated time zone"
.Vb 8
\&    $tm = Time::Moment\->new(
\&        year   => 2012,
\&        month  => 12,
\&        day    => 24,
\&        hour   => 15
\&    );
\&    $zone   = DateTime::TimeZone\->new(name => \*(AqAmerica/New_York\*(Aq);
\&    $offset = $zone\->offset_for_local_datetime($tm) / 60;
\&    
\&    say $tm\->with_offset_same_local($offset); # 2012\-12\-24T15\-05
.Ve
.SS "The Effect of Daylight Saving Time"
.IX Subsection "The Effect of Daylight Saving Time"
The time zone \fIEurope/Brussels\fR has 01:00 \s-1UTC\s0 as standard time, and 02:00 
\&\s-1UTC\s0 as daylight savings time, with transition dates according to the 
European Summer Time <http://en.wikipedia.org/wiki/Summer_Time_in_Europe>.
.PP
.Vb 1
\&    $zone = DateTime::TimeZone\->new(name => \*(AqEurope/Brussels\*(Aq);
\&    
\&    sub convert_from_instant {
\&        my ($tm, $zone) = @_;
\&        my $offset = $zone\->offset_for_datetime($tm) / 60;
\&        return $tm\->with_offset_same_instant($offset);
\&    }
\&    
\&    sub convert_from_local {
\&        my ($tm, $zone) = @_;
\&        my $offset = $zone\->offset_for_local_datetime($tm) / 60;
\&        return $tm\->with_offset_same_local($offset);
\&    }
.Ve
.PP
European Summer Time begins (clocks go forward) at 01:00 \s-1UTC\s0 on the last 
Sunday in March, in 2014 the transition date was March 30.
.PP
.Vb 4
\&    $tm1 = Time::Moment\->from_string(\*(Aq2014\-03\-29T12+01\*(Aq);
\&    $tm2 = $tm1\->plus_hours(24);
\&    say convert_from_instant($tm2, $zone); # 2014\-03\-30T13+02
\&    say convert_from_local($tm2, $zone);   # 2014\-03\-30T12+02
.Ve
.PP
During the transition from standard time to daylight savings time, the 
local time interval between 02:00:00 and 02:59:59 does not exist. Local 
time values in that interval are invalid. \f(CW\*(C`DateTime::TimeZone\*(C'\fR raises 
an exception when attempting to convert non-existing local time.
.PP
.Vb 4
\&    $tm1 = Time::Moment\->from_string(\*(Aq2014\-03\-29T22+01\*(Aq);
\&    $tm2 = $tm1\->plus_hours(4);
\&    say convert_from_instant($tm2, $zone); # 2014\-03\-30T03+02
\&    say convert_from_local($tm2, $zone);   # raises an exception
.Ve
.PP
European Summer Time ends (clocks go backward) at 01:00 \s-1UTC\s0 on the last 
Sunday in October, in 2014 the transition date was October 26.
.PP
.Vb 4
\&    $tm1 = Time::Moment\->from_string(\*(Aq2014\-10\-25T12+02\*(Aq);
\&    $tm2 = $tm1\->plus_hours(24);
\&    say convert_from_instant($tm2, $zone); # 2014\-10\-26T11+01
\&    say convert_from_local($tm2, $zone);   # 2014\-10\-26T12+01
.Ve
.PP
During the transition from daylight savings time to standard time, the
local time interval between 02:00:00 and 02:59:59 is repeated. Local 
time values in that interval are ambiguous because they occur twice.
When \f(CW\*(C`DateTime::TimeZone\*(C'\fR converts an ambiguous local time it returns 
the numerically lowest offset (usually the standard one).
.PP
.Vb 4
\&    $tm1 = Time::Moment\->from_string(\*(Aq2014\-10\-25T22+02\*(Aq);
\&    $tm2 = $tm1\->plus_hours(4);
\&    say convert_from_instant($tm2, $zone); # 2014\-10\-26T02+02
\&    say convert_from_local($tm2, $zone);   # 2014\-10\-26T02+01
.Ve
.SH "DIAGNOSTICS"
.IX Header "DIAGNOSTICS"
.ie n .IP "\fB(F)\fR Usage: %s" 4
.el .IP "\fB(F)\fR Usage: \f(CW%s\fR" 4
.IX Item "(F) Usage: %s"
Method called with wrong number of arguments.
.IP "\fB(F)\fR Parameter '%s' is out of range" 4
.IX Item "(F) Parameter '%s' is out of range"
.PD 0
.ie n .IP "\fB(F)\fR Parameter '%s' is out of the range [%d, %d]" 4
.el .IP "\fB(F)\fR Parameter '%s' is out of the range [%d, \f(CW%d\fR]" 4
.IX Item "(F) Parameter '%s' is out of the range [%d, %d]"
.ie n .IP "\fB(F)\fR Cannot coerce object of type %s to Time::Moment" 4
.el .IP "\fB(F)\fR Cannot coerce object of type \f(CW%s\fR to Time::Moment" 4
.IX Item "(F) Cannot coerce object of type %s to Time::Moment"
.IP "\fB(F)\fR Could not parse the given string" 4
.IX Item "(F) Could not parse the given string"
.ie n .IP "\fB(F)\fR %s is not an instance of Time::Moment" 4
.el .IP "\fB(F)\fR \f(CW%s\fR is not an instance of Time::Moment" 4
.IX Item "(F) %s is not an instance of Time::Moment"
.ie n .IP "\fB(F)\fR A %s object can only be compared to another %s object ('%s', '%s')" 4
.el .IP "\fB(F)\fR A \f(CW%s\fR object can only be compared to another \f(CW%s\fR object ('%s', '%s')" 4
.IX Item "(F) A %s object can only be compared to another %s object ('%s', '%s')"
.PD
.SH "THREAD SAFETY"
.IX Header "THREAD SAFETY"
\&\f(CW\*(C`Time::Moment\*(C'\fR is thread safe.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
DateTime
.PP
Time::Piece
.SH "SUPPORT"
.IX Header "SUPPORT"
.SS "Bugs / Feature Requests"
.IX Subsection "Bugs / Feature Requests"
Please report any bugs or feature requests through the issue tracker
at <https://github.com/chansen/p5\-time\-moment/issues>.
You will be notified automatically of any progress on your issue.
.SS "\s-1SOURCE CODE\s0"
.IX Subsection "SOURCE CODE"
This is open source software. The code repository is available for public 
review and contribution under the terms of the license.
.PP
<https://github.com/chansen/p5\-time\-moment>
.PP
.Vb 1
\&    git clone https://github.com/chansen/p5\-time\-moment
.Ve
.SH "AUTHOR"
.IX Header "AUTHOR"
Christian Hansen \f(CW\*(C`chansen@cpan.org\*(C'\fR
.SH "COPYRIGHT"
.IX Header "COPYRIGHT"
Copyright 2013\-2017 by Christian Hansen.
.PP
This is free software; you can redistribute it and/or modify it under
the same terms as the Perl 5 programming language system itself.
