.\" Automatically generated by Pod::Man 4.10 (Pod::Simple 3.35)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is >0, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{\
.    if \nF \{\
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{\
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\" ========================================================================
.\"
.IX Title "Exporter::Lite 3"
.TH Exporter::Lite 3 "2016-01-13" "perl v5.28.0" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Exporter::Lite \- lightweight exporting of functions and variables
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 2
\&  package Foo;
\&  use Exporter::Lite;
\&
\&  our @EXPORT    = qw($This That);      # default exports
\&  our @EXPORT_OK = qw(@Left %Right);    # optional exports
.Ve
.PP
Then in code using the module:
.PP
.Vb 2
\&  use Foo;
\&  # $This and &That are imported here
.Ve
.PP
You have to explicitly ask for optional exports:
.PP
.Vb 1
\& use Foo qw/ @Left %Right /;
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
Exporter::Lite is an alternative to Exporter,
intended to provide a lightweight subset
of the most commonly-used functionality.
It supports \f(CW\*(C`import()\*(C'\fR, \f(CW@EXPORT\fR and
\&\f(CW@EXPORT_OK\fR and not a whole lot else.
.PP
Unlike Exporter, it is not necessary to inherit from Exporter::Lite;
Ie you don't need to write:
.PP
.Vb 1
\& @ISA = qw(Exporter::Lite);
.Ve
.PP
Exporter::Lite simply exports its \fBimport()\fR function into your namespace.
This might be called a \*(L"mix-in\*(R" or a \*(L"role\*(R".
.PP
Setting up a module to export its variables and functions is simple:
.PP
.Vb 2
\&    package My::Module;
\&    use Exporter::Lite;
\&
\&    our @EXPORT = qw($Foo bar);
.Ve
.PP
Functions and variables listed in the \f(CW@EXPORT\fR package variable
are automatically exported if you use the module and don't explicitly
list any imports.
Now, when you \f(CW\*(C`use My::Module\*(C'\fR, \f(CW$Foo\fR and \f(CW\*(C`bar()\*(C'\fR will show up.
.PP
Optional exports are listed in the \f(CW@EXPORT_OK\fR package variable:
.PP
.Vb 2
\&    package My::Module;
\&    use Exporter::Lite;
\&
\&    our @EXPORT_OK = qw($Foo bar);
.Ve
.PP
When My::Module is used, \f(CW$Foo\fR and \f(CW\*(C`bar()\*(C'\fR will \fInot\fR show up,
unless you explicitly ask for them:
.PP
.Vb 1
\&    use My::Module qw($Foo bar);
.Ve
.PP
Note that when you specify one or more functions or variables to import,
then you must also explicitly list any of the default symbols you want to use.
So if you have an exporting module:
.PP
.Vb 3
\&    package Games;
\&    our @EXPORT    = qw/ pacman defender  /;
\&    our @EXPORT_OK = qw/ galaga centipede /;
.Ve
.PP
Then if you want to use both \f(CW\*(C`pacman\*(C'\fR and \f(CW\*(C`galaga\*(C'\fR, then you'd write:
.PP
.Vb 1
\&    use Games qw/ pacman galaga /;
.Ve
.SH "Methods"
.IX Header "Methods"
Export::Lite has one public method, \fBimport()\fR, which is called
automatically when your modules is \fBuse()\fR'd.
.PP
In normal usage you don't have to worry about this at all.
.IP "\fBimport\fR" 4
.IX Item "import"
.Vb 2
\&  Some::Module\->import;
\&  Some::Module\->import(@symbols);
.Ve
.Sp
Works just like \f(CW\*(C`Exporter::import()\*(C'\fR excepting it only honors
\&\f(CW@Some::Module::EXPORT\fR and \f(CW@Some::Module::EXPORT_OK\fR.
.Sp
The given \f(CW@symbols\fR are exported to the current package provided they
are in \f(CW@Some::Module::EXPORT\fR or \f(CW@Some::Module::EXPORT_OK\fR.  Otherwise
an exception is thrown (ie. the program dies).
.Sp
If \f(CW@symbols\fR is not given, everything in \f(CW@Some::Module::EXPORT\fR is
exported.
.SH "DIAGNOSTICS"
.IX Header "DIAGNOSTICS"
.ie n .IP "'""%s"" is not exported by the %s module'" 4
.el .IP "'``%s'' is not exported by the \f(CW%s\fR module'" 4
.IX Item "'%s is not exported by the %s module'"
Attempted to import a symbol which is not in \f(CW@EXPORT\fR or \f(CW@EXPORT_OK\fR.
.ie n .IP "'Can\e't export symbol: %s'" 4
.el .IP "'Can\e't export symbol: \f(CW%s\fR'" 4
.IX Item "'Can't export symbol: %s'"
Attempted to import a symbol of an unknown type (ie. the leading $@% salad
wasn't recognized).
.SH "SEE ALSO"
.IX Header "SEE ALSO"
Exporter is the grandaddy of all Exporter modules, and bundled with Perl
itself, unlike the rest of the modules listed here.
.PP
Attribute::Exporter defines attributes which you use to mark
which subs and variables you want to export, and how.
.PP
Exporter::Simple also uses attributes to control the export of
functions and variables from your module.
.PP
Const::Exporter makes it easy to create a module that exports constants.
.PP
Constant::Exporter is another module that makes it easy to create
modules that define and export constants.
.PP
Sub::Exporter is a \*(L"sophisticated exporter for custom-built routines\*(R";
it lets you provide generators that can be used to customise what
gets imported when someone uses your module.
.PP
Exporter::Tiny provides the same features as Sub::Exporter,
but relying only on core dependencies.
.PP
Exporter::Shiny is a shortcut for Exporter::Tiny that
provides a more concise notation for providing optional exports.
.PP
Exporter::Declare provides syntactic sugar to make the export
status of your functions part of their declaration. Kind of.
.PP
AppConfig::Exporter lets you export part of an AppConfig\-based
configuration.
.PP
Exporter::Lexical lets you export lexical subs from your module.
.PP
Constant::Export::Lazy lets you write a module that exports
function-style constants, which are instantiated lazily.
.PP
Exporter::Auto will export everything from your module that
it thinks is a public function (name doesn't start with an underscore).
.PP
Class::Exporter lets you export class methods as regular subroutines.
.PP
Xporter is like Exporter, but with persistent defaults and auto-ISA.
.SH "REPOSITORY"
.IX Header "REPOSITORY"
<https://github.com/neilb/Exporter\-Lite>
.SH "AUTHORS"
.IX Header "AUTHORS"
Michael G Schwern <schwern@pobox.com>
.SH "LICENSE"
.IX Header "LICENSE"
This program is free software; you can redistribute it and/or
modify it under the same terms as Perl itself.
.PP
See \fIhttp://www.perl.com/perl/misc/Artistic.html\fR
